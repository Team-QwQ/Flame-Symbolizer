# 大规模 stackcollapse 性能与阻塞规约

## 背景与问题
- 当前 `resolve-stacks.sh` 已实现地址符号化与缓存，但在处理约 39,628 行 stackcollapse 输入时，运行到第 ~8,345 行后停滞（无错误退出），怀疑存在性能瓶颈或管线阻塞。
- 预期使用场景会处理几十 K 行、每行数十帧的输入，要求全量完成且不中断；同时要避免大规模数据下的内存膨胀和溢出。

## 目标
- 保持现有 CLI 和输出语义不变的前提下，提升大规模输入处理的稳定性和吞吐，确保不会在中途卡死。
- 支持至少 100k 行 stackcollapse 输入的流式处理：持续产出输出，不因缓存、子进程或 I/O 阻塞停滞；处理完成时间与行数线性增长，无显著长尾停顿。
- 在启用 `--debug` 时，提供必要的调试输出以排查性能/阻塞原因，但不显著拖慢主流程。
- 默认启用“地址级批处理”：同一二进制的多个地址聚合为单次 `addr2line` 调用，保持逐行读写与行序输出。

## 非目标
- 不改动现有命令行参数、默认行为或输出格式。
- 不引入与本地文件格式/火焰图生成无关的新功能（如 GUI、网络服务）。
- 不要求并行化实现（除非简单安全），优先保证流式与可预测性能。

## 功能与性能需求
- **流式处理保证**：
  - 读写应当逐行、无缓冲放大；禁止依赖一次性读全文件的实现。
  - 允许输入/输出为不同文件或管道，避免自覆盖导致的数据丢失或阻塞；若检测到同一路径读写需显式报错或警告。
- **子进程调用开销**：
  - 默认地址级批处理：按二进制分桶聚合待解析地址，一次性调用 `addr2line` 处理多地址；保持行序输出，对同一地址仍复用缓存结果。
  - 对同一 `<binary, address>` 组合的符号查找应尽量批量化或重用，减少 `addr2line` 调用次数；若无法批量，也需保证每次调用有超时/失败退让，避免卡死。
  - `readelf` 探测 ELF 类型应严格缓存，避免重复调用。
- **符号目录扫描**：
  - 对每个模块的符号目录查找只做一次（或有限次数），避免在大输入下反复 `find`；保持查找结果（命中或缺失）缓存。
- **缓存与内存占用**：
  - 地址缓存、模块缓存需有上限或可选禁用策略，防止几十万帧导致内存异常增长；至少需评估并记录缓存尺寸与风险。
- **健壮性**：
  - 对 `addr2line`/`readelf` 失速、挂起、输出异常需有保护：如可配置的超时、失败后标记模块不可解析并继续流水线。
  - 对 maps 未命中、负偏移、超范围地址继续输出原始地址并告警，不应阻塞后续行。
- **可观察性**：
  - 在 `--debug` 模式下输出核心计数/里程碑（如已处理行数、命中/未命中模块数、被跳过的 addr2line 调用数），便于定位停滞位置。

## 接口与兼容性
- CLI、选项及默认行为保持不变；新增的性能相关开关（如超时、缓存上限）需为可选参数，默认保持当前行为但不引入卡死风险。
- 输出格式与错误/警告信息风格与现有脚本一致，新增告警需带 `[WARN]` 前缀。

## 验收标准
- 基于现有夹具测试仍然通过。
- 构造至少 40k 行、含多模块、多地址的合成输入，脚本能在可接受时间内（如 <30s，具体视环境记录）完成输出，无卡死；处理行数应等于输入行数。
- 在 `--debug` 模式下，能看到行进度或至少能定位停滞区间；无 debug 模式时性能不得显著劣化。
- 当 `addr2line` 或符号目录缺失时，脚本应继续流式输出，并在同模块上仅告警一次。
- 默认配置下，同一二进制的多地址会被批量提交给 `addr2line`，调用次数较逐地址模式显著减少（可通过 debug/计数验证）。

## 风险与待决问题
- Bash 下 64 位整型上限与地址计算：需验证极高地址是否会溢出，必要时切换到 `printf/awk` 进行无符号计算。
- `addr2line` 批量调用的可行性取决于不同版本兼容性；若不支持安全批量，需要评估超时/重试方案。
- 大目录下的 `find` 仍可能昂贵；可能需要预先索引或限制搜索深度。

## 相关参考
- 主规格：[specs/addr2line-symbolizer.md](addr2line-symbolizer.md)
- 现有计划：[plans/2025-12-17-addr2line-plan.md](../plans/2025-12-17-addr2line-plan.md)
