# 地址符号化脚本规格

## 背景与问题
- 实际运行环境多为 release 版本，产物默认剥离符号表，任何采集到的栈本来就仅含地址；若不先符号化就直接生成火焰图，将无法读懂热点函数。
- 当前 flamegraph 输入文件（stackcollapse.pl 输出）包含大量 `0x` 开头的地址，阅读和分析困难。
- 分析人员通常需要依赖 `addr2line` 将地址反查到源码函数，但手工流程耗时且容易出错。
- 需要一个可重复执行的 shell 脚本，对同一日志多轮解析：先针对带符号表的可执行文件，再针对动态库逐步补全符号。

## 目标
- 提供一个可脚本化的“地址→函数名”替换工具，支持批量处理 stackcollapse 文本。
- 支持配置 `addr2line` 可执行文件（以适配交叉编译工具链）。
- 支持读取进程 maps 自动恢复各模块加载基址，作为地址矫正依据。
- 保持输入格式，确保无法解析的地址仍以原样输出。

## 非目标
- 不负责运行 stackcollapse 或生成 flamegraph，本工具仅负责地址替换。
- 不实现 GUI 或交互式功能。
- 不处理非十六进制地址格式的符号解析。

## 输入/输出格式
- **输入**：文本文件或标准输入，行格式形如 `frame1;frame2;...;frameN; count`，其中 frame 可能是地址或已解析符号。
- **输出**：与输入行数一致；若地址解析成功，frame 被函数签名（`<function>(file:line)` 或 `function (source:line)`）替代；解析失败则维持原 `0x...` 片段。
- 行尾计数及分隔符保持不变；脚本尽量不改动已为符号的帧。

## 核心功能需求
1. **解析流程**
   - 逐行拆分 `;` 分隔的帧，识别 `^0x[0-9a-fA-F]+$` 形式的片段。
   - 对每个地址调用 `addr2line -e <binary> <address>`（或包含 `--adjust-vma` 类参数）得到 `function@file:line`。
   - 允许缓存同一地址到符号的映射，避免重复调用。
2. **多轮可执行**
   - 输入/输出可为同一路径（覆盖）或不同路径，确保脚本在部分符号已解析的情况下仍可继续处理剩余地址。
   - 仅对未解析的 `0x...` 地址尝试替换，避免破坏已有符号文本。
3. **映射驱动的加载地址恢复**
   - 通过必选 `--maps <file>` 参数读取 `/proc/<pid>/maps` 式文本，一次性解析全部区间，并按 `start-end perms offset dev inode path` 构建段表。
   - 解析时根据地址命中段表自动推断所属模块及段起始地址，进而计算 `实际地址 = 原始地址 - 段起始` 再传给 `addr2line`。
   - 从 maps 中解析到的 `path` 仅能通过 `--symbol-dir`（可多次提供）指向的符号表目录集合来解析，脚本不会直接访问宿主机的同名路径。每个符号目录按声明顺序尝试，并可支持 glob/相对路径；匹配逻辑为“先把 maps 中的原始路径当作 sysroot 下的相对路径”，若失败再退化为仅按文件名匹配。命中后直接使用该目录内的文件，不做额外推断或复制。
   - 若所有 `--symbol-dir` 都无法定位到对应文件，脚本应在 `stderr` 输出警告并保留原地址继续处理，以保证流水线不中断。
   - 如未提供可读的 maps 文件，脚本应报错并退出，以避免在 release 产物上产生错误的符号偏移。
4. **自定义 addr2line**
   - 参数或环境变量指定 `addr2line` 路径，便于使用交叉工具链（例如 `aarch64-linux-gnu-addr2line`）。
   - 允许追加透传参数（如 `-f -C`）以获得 demangle 后的函数名。
5. **健壮性**
   - 若 `addr2line` 返回 `??:0` 或非零退出码，视为解析失败并保留原地址。
   - 对输入文件不存在、权限不足、命令缺失等情况输出明确错误信息并返回非零状态。

## 命令行设计草案
```
 resolve-stacks.sh \
    --input stack.txt --output stack.resolved.txt \
      [--symbol-dir /opt/firmware/symbols/**] \
      --maps /tmp/proc-maps.txt \
    [--addr2line aarch64-linux-gnu-addr2line] \
    [--addr2line-flags "-f -C"]
```
- `--symbol-dir`：可重复指定、支持 glob 与相对路径，按声明顺序搜索；针对每个目录先尝试把 maps 中的绝对路径拼接到目录下（模拟 sysroot），再退化为仅按文件名匹配，命中即停止。若未提供任何符号目录，则脚本无法解析任何地址并会发出警告。
- `--maps`：必选，读取进程 maps 文件，自动推导段起始及默认二进制路径，是计算偏移的唯一来源。
- 若未提供 `--input`/`--output`，默认走 stdin/stdout，便于管道复用。

## 性能与扩展
- 建议对每个 `<binary,addr>` 组合做内存缓存，避免同一地址重复调用 `addr2line`。
- 面向未来的扩展：可加入并行解析或 JSON 输出，但当前版本不做要求。

## 验收标准
- 给定示例输入，两行中的每个地址都被替换为 `addr2line` 返回的函数名；若某个地址无符号，原样保留。
- 脚本支持通过 `--addr2line aarch64-linux-gnu-addr2line` 切换工具。
- 解析时须强制提供 maps 文件；同一地址的解析结果应与使用 `addr2line --adjust-vma=<maps 段起始>` 手动计算一致。
- maps 文件应驱动地址到模块与二进制路径的自动匹配：只有当对应二进制可在 `--symbol-dir` 提供的目录中定位到（无论是 sysroot 拼接还是文件名匹配）时才可用于 `-e`，即使宿主机存在同名路径也不得直接使用。
- 当某个地址无法在任何符号目录中定位到二进制时，脚本应输出带前缀的警告（例如 `[WARN] missing binary for /lib/libfoo.so`），并继续尝试解析后续帧，最终保留原地址。
- 覆盖（原地修改）与“读 stdin / 写 stdout”两种模式都能工作。
- 对不可读取的输入文件或 `addr2line` 不存在的情况返回非零退出码并输出错误描述。

## 风险与未决问题
- 模块名称的提取规则取决于 stackcollapse 输出，需在实现阶段根据实际数据做正则适配。
- 是否需要支持符号化同时输出源文件路径缩写？暂不要求，可在实现阶段再评估。
