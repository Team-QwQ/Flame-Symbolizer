# 大规模 stackcollapse 性能与阻塞规约

## 背景与问题
- 当前 `resolve-stacks.sh` 已实现地址符号化与缓存，但在处理约 39,628 行 stackcollapse 输入时，运行到第 ~8,345 行后停滞（无错误退出），怀疑存在性能瓶颈或管线阻塞。
- 预期使用场景会处理几十 K 行、每行数十帧的输入，要求全量完成且不中断；同时要避免大规模数据下的内存膨胀和溢出。

## 目标
- 保持现有解析语义不变的前提下，提升大规模输入处理的稳定性和吞吐，确保不会在中途卡死。
- 以性能为最高优先级，当前版本不再支持 stdin/stdout 流式管道，强制文件输入/输出，允许更激进的批处理与内存/缓冲优化。
- 支持至少 100k 行 stackcollapse 输入的高吞吐处理：处理完成时间与行数线性增长，无显著长尾停顿。
- 在启用 `--debug` 时，提供必要的调试输出以排查性能/阻塞原因，但不显著拖慢主流程。
- 默认启用“地址级批处理”：同一二进制的多个地址聚合为单次 `addr2line` 调用。

## 非目标
- 不改动现有命令行参数、默认行为或输出格式。
- 不引入与本地文件格式/火焰图生成无关的新功能（如 GUI、网络服务）。
- 不要求并行化实现（除非简单安全），优先保证流式与可预测性能。

## 功能与性能需求
- **I/O 模式与缓冲**：
  - 仅支持文件输入/输出，不支持 stdin/stdout 管道；可按性能需求调整读取缓冲或分批处理策略。
  - 输入/输出路径必须不同；若检测到同一路径读写需显式报错或警告。
- **子进程调用开销**：
  - 默认地址级批处理：按二进制分桶聚合待解析地址，一次性调用 `addr2line` 处理多地址；保持行序输出，对同一地址仍复用缓存结果。
  - 对同一 `<binary, address>` 组合的符号查找应尽量批量化或重用，减少 `addr2line` 调用次数；若无法批量，也需保证每次调用有超时/失败退让，避免卡死。
  - `readelf` 探测 ELF 类型应严格缓存，避免重复调用。
  - 进程/命令装配开销应降低：参数解析后预组装 `addr2line` 命令前缀（含可选 flags），批量与单地址回退均重用该前缀，避免每批动态拆装 flags；若未开启批量或批量失败退化为单地址时，也应沿用同一命令模板以减少 argv 重建与重复解析成本。
  - readelf/工具调用路径需一次性确定：在参数解析阶段定位工具路径、记录缺失状态，后续分支直接走缓存结果或 UNKNOWN 快速路径，避免在热路径反复探测或打印重复告警。
  - 减少外部命令调用：
    - 解析 readelf 输出时尽量使用单次管道/内建，而非多次 grep/head。
    - 频繁路径检查/字符串处理优先用 bash 内建替代 `basename`/`dirname` 调用。
  - I/O 与 stderr 争用需控制：保持行级单次写出，不对单帧多次 `printf`；警告和 debug 输出可按行块或批次节流，避免在大输入下拖慢处理；若需要更大读缓冲，可作为可选优化但不得破坏流式特性。
- **符号目录扫描**：
  - 对每个模块的符号目录查找只做一次（或有限次数），避免在大输入下反复 `find`；保持查找结果（命中或缺失）缓存。
- **缓存与内存占用**：
  - 地址缓存、模块缓存需有上限或可选禁用策略，防止几十万帧导致内存异常增长；至少需评估并记录缓存尺寸与风险。
- **健壮性**：
  - 对 `addr2line`/`readelf` 失速、挂起、输出异常需有保护：如可配置的超时、失败后标记模块不可解析并继续流水线。
  - 对 maps 未命中、负偏移、超范围地址继续输出原始地址并告警，不应阻塞后续行。
- **可观察性**：
  - 默认在 stderr 输出 `[INFO]` 级进度与 summary：首遍行进度/唯一地址计数、桶构建进度、批处理进度/总批次、二遍行进度以及最终总计（行数、批次数、模块命中/缺失、跳过计数），周期由内部阈值控制。
  - `--debug` 模式下输出更详细的段表、命中决策与降级提示，便于定位停滞位置。

## 接口与兼容性
- CLI、选项及默认行为保持不变；新增的性能相关开关（如超时、缓存上限）需为可选参数，默认保持当前行为但不引入卡死风险。
- 输出格式与错误/警告信息风格与现有脚本一致，新增告警需带 `[WARN]` 前缀。

## 验收标准
- 基于现有夹具测试仍然通过。
- 构造至少 40k 行、含多模块、多地址的合成输入，脚本能在可接受时间内（如 <30s，具体视环境记录）完成输出，无卡死；处理行数应等于输入行数。
- 在 `--debug` 模式下，能看到行进度或至少能定位停滞区间；无 debug 模式时性能不得显著劣化。
- 当 `addr2line` 或符号目录缺失时，脚本应继续流式输出，并在同模块上仅告警一次。
- 默认配置下，同一二进制的多地址会被批量提交给 `addr2line`，调用次数较逐地址模式显著减少（可通过 debug/计数验证）。

## 风险与待决问题
- Bash 下 64 位整型上限与地址计算：需验证极高地址是否会溢出，必要时切换到 `printf/awk` 进行无符号计算。
- `addr2line` 批量调用的可行性取决于不同版本兼容性；若不支持安全批量，需要评估超时/重试方案。
- 大目录下的 `find` 仍可能昂贵；可能需要预先索引或限制搜索深度。

## 相关参考
- 主规格：[specs/2025-12-17-addr2line-spec.md](2025-12-17-addr2line-spec.md)
- 现有计划：[plans/2025-12-17-addr2line-plan.md](../plans/2025-12-17-addr2line-plan.md)
- 性能计划：[plans/2025-12-18-addr2line-performance-plan.md](../plans/2025-12-18-addr2line-performance-plan.md)
