# find_map_segment 二分查找优化规格

## 背景与问题
- `find_map_segment` 当前对 `MAP_STARTS`/`MAP_ENDS` 进行线性扫描，复杂度 O(S)（S 为 maps 段数）。
- 对于唯一地址数 U 较大、S 较多的进程（几十到几百段），线性查找会放大 CPU 开销，成为 `first_pass_collect` 的热点。
- `/proc/<pid>/maps` 自身已按起始地址升序，具备二分查找的先决条件。

## 目标
- 将 `find_map_segment` 查找从 O(S) 优化为 O(log S)，在大输入场景降低 CPU 时间。
- 保持符号解析结果与现有实现一致（正确的段匹配与调整量）。
- 无需改变 CLI、输入输出格式或现有日志语义。

## 非目标
- 不合并或重写 maps 段（避免因空洞/权限/offset 差异导致错误）。
- 不调整 addr2line 调用、去重策略或其它阶段的逻辑。
- 不引入额外依赖或编译步骤，仍保持纯 Bash。

## 方案概述
- 利用 maps 已按起始地址排序的事实，对 `MAP_STARTS`/`MAP_ENDS` 进行二分查找。
- 二分命中策略：找到最后一个 `start <= addr` 的索引，再验证 `addr < end`；若不满足则视为未覆盖。
- 处理潜在重叠：若存在相同 start 的多段，保持与现有行为等价（最左匹配）。如需防御，命中后可向左扫描相同 start 以保持一致性。
- 调试/日志：不新增对外日志，仅保留现有 DEBUG 输出；必要时可在 DEBUG 下记录二分参数用于排障。

## 需求与约束
- 语言/环境：Bash，兼容当前脚本的 shell 设定（`set -euo pipefail`）。
- 复杂度：查找阶段降至 O(log S)；内存占用与现状相当（复用现有数组）。
- 健壮性：遇到未覆盖地址仍按现有路径警告并返回未解析。
- 兼容性：`load_maps` 生成的数组顺序不可被破坏；不得引入排序改变段相对顺序的副作用。

## 接口/数据结构
- 仅内部函数 `find_map_segment` 行为优化，签名不变：输入十进制地址，返回段索引或失败。
- 继续使用并行数组 `MAP_STARTS`/`MAP_ENDS`/`MAP_OFFSETS`/`MAP_PATHS`/`MAP_ADJUSTS`。

## 验收标准
- 功能正确性：
  - 现有 fixture `tests/run-fixture.sh` 通过；输出与当前主分支一致（逐字节相同）。
- 性能改进：
  - 在含 ≥500 段、≥50k 唯一地址的合成或真实输入上，对比优化前后，`first_pass_collect` 所耗 CPU 时间下降（目标 ≥20% 的段查找开销节省；整体运行至少可观可测）。
- 回退安全：
  - 若 maps 输入异常（未覆盖、非文件段等），警告和返回路径与当前行为一致。

## 风险与缓解
- 风险：二分实现错误导致漏段或选错段，进而产生错误偏移。
  - 缓解：添加针对边界（首段、末段、恰在边界、未覆盖、重复 start）的小型单元/合成用例，比较线性查找与二分结果一致性（可在开发阶段本地验证）。
- 风险：重叠段的解析顺序与现状不一致。
  - 缓解：二分命中后向左探查同 start 的最左段，或保持当前 maps 顺序前提下取最左匹配。

## 开放问题
- 是否需要在 DEBUG 下暴露一次性 maps 段数和二分选择的索引，用于后续性能评估？
- 是否需要提供可选环境变量/标志以回退线性查找（默认仍启用二分）以便快速 A/B 对比？
