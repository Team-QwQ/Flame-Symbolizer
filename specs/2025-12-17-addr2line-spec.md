# 地址符号化脚本规格

## 背景与问题
- 实际运行环境多为 release 版本，产物默认剥离符号表，任何采集到的栈本来就仅含地址；若不先符号化就直接生成火焰图，将无法读懂热点函数。
- 当前 flamegraph 输入文件（stackcollapse.pl 输出）包含大量 `0x` 开头的地址，阅读和分析困难。
- 分析人员通常需要依赖 `addr2line` 将地址反查到源码函数，但手工流程耗时且容易出错。
- 需要一个可重复执行的 shell 脚本，对同一日志多轮解析：先针对带符号表的可执行文件，再针对动态库逐步补全符号。

## 目标
- 提供一个可脚本化的“地址→函数名”替换工具，支持批量处理 stackcollapse 文本。
- 支持配置 `addr2line` 可执行文件（以适配交叉编译工具链）。
- 支持读取进程 maps 自动恢复各模块加载基址，作为地址矫正依据。
- 保持输入格式，确保无法解析的地址仍以原样输出。
- 以性能为最高优先级，当前版本不再支持 stdin/stdout 流式管道，强制使用文件输入/输出以便优化批处理与资源管理。

## 非目标
- 不负责运行 stackcollapse 或生成 flamegraph，本工具仅负责地址替换。
- 不实现 GUI 或交互式功能。
- 不处理非十六进制地址格式的符号解析。

## 输入/输出格式
- **输入**：必须为可读文本文件（stackcollapse 格式），不再支持从 stdin 读取。
- **输出**：必须为文件路径，生成的文本与输入行数一致；若地址解析成功，frame 被函数签名替代；解析失败则维持原 `0x...` 片段。默认不支持写 stdout。
- **覆盖模式**：若未指定 `--output` 或显式将 `--output` 设为与 `--input` 相同路径，则走“原地覆盖”流程：先写入同目录临时文件并 fsync，再使用同一文件系统内的原子 `mv` 覆盖输入文件；失败时保留原文件并报告临时文件位置。
- 默认符号格式改为不包含文件名/行号（`none`），避免因相对/基名差异导致已符号帧在 stackcollapse 阶段被拆成多份；可通过 `--location-format short|full` 开启文件名与行号（短名或含路径）。
- 行尾计数及分隔符保持不变；脚本尽量不改动已为符号的帧。

## 核心功能需求
1. **解析流程（两阶段批处理优先）**
   - 读取完整输入，按帧拆分后收集全部 `^0x[0-9a-fA-F]+$` 地址，并按模块分桶、去重；不需考虑内存占用约束。
   - 在进入模块分桶前，增加一层“原始地址”全局去重（raw 地址字典），先过滤重复地址再进行 maps 匹配和分桶，以降低重复解析开销；全局去重后无需再对同一二进制单独判重。
   - 对每个模块批量调用 `addr2line -e <binary> <addr1> <addr2> ...` 获取 `function@file:line`，将结果映射缓存后再整体回填到各行，保持原有行序与计数。
   - 支持 addr2line 单次参数数量上限：当去重后地址过多时需分块（chunk）多次调用，仍保持模块内批处理；块大小可配置或设定保守默认，以确保兼容常见 addr2line 实现。
   - 允许缓存同一地址到符号的映射，避免重复调用；缺失二进制时使用负缓存短路后续查找。
2. **多轮可执行**
   - 输入/输出可为同一路径（覆盖）或不同路径；未提供 `--output` 时默认覆盖输入路径。覆盖流程需使用同目录临时文件 + 原子重命名，失败时保留原文件。
   - 仅对未解析的 `0x...` 地址尝试替换，避免破坏已有符号文本。
3. **映射驱动的加载地址恢复**
   - 通过必选 `--maps <file>` 参数读取 `/proc/<pid>/maps` 式文本，一次性解析全部区间，并按 `start-end perms offset dev inode path` 构建段表。
   - 解析时根据地址命中段表自动推断所属模块及段起始地址，进而计算 `实际地址 = 原始地址 - 段起始` 再传给 `addr2line`。
   - 自动识别命中的二进制 ELF 类型：若为 `ET_EXEC`（非 PIE 可执行），应直接使用运行时地址调用 `addr2line`（不扣减加载基址）；若为 `ET_DYN`（PIE/DSO），按 maps 段起始/offset 计算相对地址；无法识别类型时退化为相对地址策略。
    - 从 maps 中解析到的 `path` 仅能通过 `--symbol-dir`（可多次提供）指向的符号表目录集合来解析，脚本不会直接访问宿主机的同名路径。每个符号目录按声明顺序尝试，并可支持 glob/相对路径；匹配逻辑为：
       1) 先尝试“根平铺”命中：在符号目录根直接按文件名查找；
       2) 若失败，再按 sysroot 思路，将 maps 中的原始绝对路径拼接到符号目录下；
       3) 若仍失败，退化为仅按文件名匹配（如 basename 搜索）；
       命中即停止，命中后直接使用该目录内的文件，不做额外推断或复制。
   - 若所有 `--symbol-dir` 都无法定位到对应文件，脚本应在 `stderr` 输出警告并保留原地址继续处理，以保证流水线不中断。
   - 如未提供可读的 maps 文件，脚本应报错并退出，以避免在 release 产物上产生错误的符号偏移。
4. **工具链配置**
   - 支持通过前缀指定交叉工具链（如 `aarch64-linux-gnu-`），脚本按此前缀调用 `addr2line`、`readelf` 等工具；同时允许显式覆盖 `addr2line` 路径（覆盖值优先于前缀）。
   - 允许追加透传参数（如 `-f -C`）以获得 demangle 后的函数名。
5. **健壮性**
      - 若 `addr2line` 返回 `??:0` 或非零退出码，视为解析失败并保留原地址；单次失败不得屏蔽该模块的其他地址，后续帧仍会尝试解析。
   - 对输入文件不存在、权限不足、命令缺失等情况输出明确错误信息并返回非零状态。
6. **可见性与告警**
   - 术语说明：本规格中的“二进制”“模块二进制”均指 maps 中对应的可执行映像文件，可为主进程可执行文件或动态库，二者在本文中同义。
   - 默认在 stderr 输出 `[INFO]` 级进度与总结：首遍行进度、唯一地址计数/桶构建进度、批处理进度/总批次、二遍行进度，以及最终 summary（行数、批次数、模块命中/缺失、跳过计数）；周期由内部常量控制（如 `PROGRESS_LOG_EVERY`）。
   - 提供可选调试开关，开启后在 `stderr` 打印已解析的段表、命中的符号目录及解析决策（例如命中文件、调整后的地址偏移）；调试输出不应影响正常 stdout 结果，且可控关闭以便流水线集成。
    - 符号缺失类告警区分：
       - 找不到模块二进制：对同一模块仅告警一次以降噪。
       - 找到二进制但符号缺失/addr2line 返回 `??`：允许多次告警（逐次或至少按帧/批次），以便提醒可能是错误二进制；但仍不应全局屏蔽该模块，后续地址继续尝试解析。

## 命令行设计草案
```
 resolve-stacks.sh \
      --input stack.txt [--output stack.resolved.txt] \
         [--symbol-dir /opt/firmware/symbols/**] \
         --maps /tmp/proc-maps.txt \
         [--toolchain-prefix aarch64-linux-gnu-] \
         [--addr2line aarch64-linux-gnu-addr2line] \
         [--addr2line-flags "-f -C"] \
         [--location-format none|short|full] \
         [--debug]
```
- `--symbol-dir`：可重复指定、支持 glob 与相对路径，按声明顺序搜索；针对每个目录的匹配顺序为：先在目录根平铺按文件名查找；若失败再将 maps 原始绝对路径拼接到目录下（模拟 sysroot）；若仍失败再退化为 basename 递归匹配，命中即停止。若未提供任何符号目录，则脚本无法解析任何地址并会发出警告。
- `--maps`：必选，读取进程 maps 文件，自动推导段起始及默认二进制路径，是计算偏移的唯一来源。
- 若未提供 `--input`/`--output`，默认走 stdin/stdout，便于管道复用。
- `--toolchain-prefix`：可选，指定交叉工具链前缀（如 `aarch64-linux-gnu-`），用于调用 `addr2line`、`readelf` 等工具。
- `--addr2line`：可选，覆盖 addr2line 可执行路径；若同时提供前缀，以覆盖值为准。
- `--location-format`：控制输出是否携带文件与行号，`none` 表示仅输出函数名（默认，避免 stackcollapse 因文件名差异拆分同一符号），`short` 输出函数名和文件名（无路径）与行号，`full` 输出函数名和带路径的文件名与行号。
- `--debug`：开启后在 `stderr` 输出调试信息，包括 maps 段表、符号目录命中情况与地址调整决策；默认关闭。

## 性能与扩展
- 建议对每个 `<binary,addr>` 组合做内存缓存，避免同一地址重复调用 `addr2line`。
- 面向未来的扩展：可加入并行解析或 JSON 输出，但当前版本不做要求。

## 验收标准
- 给定示例输入，两行中的每个地址都被替换为 `addr2line` 返回的函数名；若某个地址无符号，原样保留。
- 脚本支持通过 `--toolchain-prefix` 选择交叉工具链（用于 `addr2line`、`readelf` 等），并可用 `--addr2line` 显式覆盖 addr2line。
- 解析时须强制提供 maps 文件；同一地址的解析结果应与使用 `addr2line --adjust-vma=<maps 段起始>` 手动计算一致。
- maps 文件应驱动地址到模块与二进制路径的自动匹配：只有当对应二进制可在 `--symbol-dir` 提供的目录中定位到（无论是 sysroot 拼接还是文件名匹配）时才可用于 `-e`，即使宿主机存在同名路径也不得直接使用。
 - 对非 PIE 可执行（ELF `ET_EXEC`）的地址，符号化应直接使用运行时地址；对 PIE/DSO（`ET_DYN`）使用基址调整，无法识别类型时使用相对地址策略。
- 当某个地址无法在任何符号目录中定位到二进制时，脚本应输出带前缀的警告（例如 `[WARN] missing binary for /lib/libfoo.so`），并继续尝试解析后续帧，最终保留原地址。
- 覆盖（原地修改）与“读 stdin / 写 stdout”两种模式都能工作；覆盖模式需在同一文件系统内写临时文件并原子重命名输入路径，失败应保留原文件。
- 对不可读取的输入文件或 `addr2line` 不存在的情况返回非零退出码并输出错误描述。
- 当 `--location-format` 为 `none` 时输出不包含文件与行号；为 `short` 时输出文件名（无路径）与行号；为 `full` 时文件名携带路径前缀。
- 开启 `--debug` 时，stderr 能看到段表、符号目录命中与地址调整日志，且 stdout 结果不受影响。
- 找不到模块二进制时，应输出警告且对同一模块仅告警一次；找到二进制但符号缺失或 addr2line 产出 `??` 时，可多次输出警告以提示可能二进制错误，但不能因单次失败跳过该模块后续地址的解析。

## 风险与未决问题
- 模块名称的提取规则取决于 stackcollapse 输出，需在实现阶段根据实际数据做正则适配。
- 是否需要支持符号化同时输出源文件路径缩写？暂不要求，可在实现阶段再评估。
