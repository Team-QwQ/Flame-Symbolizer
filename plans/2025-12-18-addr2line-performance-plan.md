# addr2line 性能与批处理实施计划（2025-12-18）

## 范围与依据
- 范围：在不改变 CLI/输出语义的前提下，解决大规模输入的性能与阻塞问题，默认启用地址级批处理，并确保流式、行序输出与可观测性。
- 规范：
  - [specs/addr2line-performance.md](../specs/addr2line-performance.md)
  - [specs/addr2line-symbolizer.md](../specs/addr2line-symbolizer.md)

## 假设与不在范围
- 输入为标准 stackcollapse 文本；maps 与符号目录能匹配真实模块路径或文件名。
- 环境提供 bash、GNU addr2line/readelf；若缺失则按规范的降级策略执行。
- 不实现 GUI/服务端，不引入非必要并行；仅做地址级批处理和必要的健壮性增强。

## 计划步骤（有序可验证）
1) 参数与兼容性
   - 确认不新增破坏性 CLI；如需新增性能开关（批量大小/超时）默认保持当前行为但启用地址批处理。
   - 帮助文档与 README 补充批处理/性能说明。
2) 批处理核心实现
   - 在逐行读写框架下，按二进制分桶收集待解析地址，批量调用 addr2line（支持多地址参数），保持行序输出。
   - 同一地址继续使用缓存；批处理结果写回缓存与行内帧。
   - 参数解析后预组装 addr2line 命令前缀（含 flags），批量与单地址回退重用该前缀，减少每批 argv 组装与解析开销。
   - 减少外部命令：解析 readelf 结果用单次管道/内建，路径处理优先用内建替代 basename/dirname，避免热路径多次外部调用。
3) 健壮性与防阻塞
   - readelf 仍严格缓存，缺失时快速走 UNKNOWN 分支不重复探测。
   - 工具探测在参数解析阶段一次性完成：`command -v` 校验 addr2line 缺失即中止；readelf 缺失仅警告一次并置 `READ_ELF_AVAILABLE=0`，后续热路径不再尝试。
   - ELF 类型探测缓存：`detect_elf_type` 命中缓存直接返回；readelf 不可用或调用失败时写入 UNKNOWN 并复用，避免后续重复探测。
   - 防止输入输出同路径覆盖造成数据丢失或阻塞，必要时提示或拒绝。
   - 评估整数溢出风险，必要时改用无符号计算路径。
   - I/O 与 stderr 争用：保持行级单次写出。
4) 可观察性与统计
   - `--debug` 模式输出关键计数：已处理行数、批处理调用次数、命中/未命中模块数、跳过的 addr2line 调用数，便于定位停滞。
5) 测试与验证
   - 保持现有夹具通过。
   - 构造 ≥40k 行合成输入（多模块、多地址）验证：行数对齐、无卡死、默认批处理下 addr2line 调用次数明显下降；记录耗时。
   - 验证缺符号、maps 未命中、readelf/addr2line 缺失的告警与降级路径。

## 验证策略
- 脚本级：运行现有 fixture；新增大数据合成用例（可放临时脚本或测试目录）。
- 性能观测：统计 addr2line 调用次数/批大小（debug 输出或计数器），确认较逐地址模式减少。
- 稳定性：模拟 addr2line 失败/超时/缺符号，确保流水线不中断且只警告一次。

## 风险与缓解
- addr2line 批量兼容性差异：如遇不支持多地址，自动退化为单地址模式并告警。
- 大输入导致内存占用上涨：必要时增加可选缓存上限或分批刷新桶；观察实际占用。
- 并发未引入，本计划不做多 worker，降低复杂度。

## 进度与下一阶段
- 当前状态：/plan 待审核。
- 审核通过后进入 `/do` 实施上述步骤。
